#!/usr/bin/perl
###
# Script which will do some basic translation of vim regex patterns to perl.
# Allows you to use ack as the vim grepprg without losing the ability to run
# :grep <ctrl-r>/
###

use strict;

# Ack installed as perl module.
eval {
  require App::Ack;
  App::Ack->import();
};

# Ack installed as standalone script.
if ($@){
  my $ackpath = `which ack`;
  $ackpath =~ s/(^\s+|\s+$)//;
  print "vimack: using standalone ack: $ackpath\n";
  my $ackcontent;
  {
    local $/=undef;
    open FILE, "$ackpath" or die "Couldn't open file: $!";
    $ackcontent = <FILE>;
    close FILE;
  }
  # hack to prevent variable warnings on eval of standalone ack.
  open(SAVE, '>&STDERR') or die $!;
  open(STDERR, '>/dev/null');
  eval "package AckStandalone; sub {" . $ackcontent . "}";
  open( STDERR, '>&SAVE' ) or die $!;
}

my @args= @ARGV;
my $opt = App::Ack::get_command_line_options();
my $regex = App::Ack::build_regex(defined $opt->{regex} ?
  $opt->{regex} : shift @ARGV, $opt);
my $regex_orig = $regex;

# remove leading \V that vim may add when using '*'
$regex =~ s/^\\V//g;

# translate word boundries
$regex =~ s/\\[<>]/\\b/g;

# translate non-greedy
$regex =~ s/\\{-}/*?/g;

# translate expressions that are escaped in vim, but not in perl.
# doing this makes it impossible to use a perl expression which actually needs
# the escaped literal value.
#$regex =~ s/\\([()|?+])/\1/g;

if ($regex ne $regex_orig){
  print "vimack: $regex_orig -> $regex\n";

  my $index = 0;
  foreach (@args) {
    if ($_ eq $regex_orig){
      @args[$index] = $regex;
    }
    $index++;
  }
}

unshift(@args, '--column'); # utilize my patch for rendering column numbers
unshift(@args, '-H'); # ensure ack always prints filename
unshift(@args, 'ack');

my $cmd = join(' ', @args);
print "vimack: $cmd\n";

my $exit_code = system(@args);
$exit_code >>= 8;
exit($exit_code);
